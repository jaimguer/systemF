\documentclass{amsart}
\usepackage{amsmath}
\usepackage{amsfonts}

\author{Jaime Guerrero}
\title{A System F Implementation in Agda}
\date{August 1, 2014}

\begin{document}

\maketitle

\section{Overview}
This Agda implementation of System F is based upon Benjamin Pierce's
implementation as described in \textit{Types and Programming Langauges} and
his website.  This document outlines the basic components of and their
interactions.

\section{Types, Terms, and Bindings}
Within System F, the basic objects of discourse are Types and Terms.  The
types are given by the grammar
\begin{align*}
\tau = Nat ~|~ Boolean ~|~ TypeVar ~i~ ~|~ \tau \Rightarrow \tau ~|~ Forall ~\tau ~|~ Empty
\end{align*}
where $i \in \mathbb{N}$.  Overall, these are typical types for System F, with
the exception of $Empty$.  It's inclusion is for convenience; there are
situations where Agda's requirement for function totality calls for a type to
represent an error.  Any type that has $Empty$ as a subtype will be considered
invalid.

Terms are given by the grammar
\begin{align*}
    e &= Var ~i ~|~ Lam~ \tau ~e ~|~ App ~e~ e~ |~ TypeAbs ~e ~|~ TypeApp ~e ~|~ \\
      & ~~~Num ~i ~|~ Succ ~e ~|~ True ~|~ False ~|~ If ~e ~e ~e ~|~ Empty
\end{align*}
where $i \in \mathbb{N}$. Again, the inclusion of $Empty$ is a convenience;
any term with $Empty$ as a subterm is ill-formed.

This implementation uses de Bruijn indices for variables in relation to $Lam$
tags, and type variables in relation to $TypeAbs$ tags.

Bindings are generated by the following:
\begin{align*}
    b = TypeVarBind ~|~ VarBind~ \tau ~|~ TyAbbBind~ \tau ~|~ TmAbbBind~ e~ \tau
\end{align*}

$TmAbbBind$ is used within both the evaluator and the type checker since it
holds the expression that will replace a term variable, along with the
expression's type.  The other three binders are only used within the
type-checker.  Whenever a variable is encountered, its type is captured with
a $VarBind$.  A $TypeVarBind$ is pushed onto the context upon finding a type
variable; since a type variable does not have an explicit type bound to it,
a $TypeVarBind$ carries along no other information.  A $TyAbbBind$ holds
a type that will replace a type variable.  It's purpose is most clearly seen
in the function \texttt{typeEq}, found in \texttt{TypeCheck.agda}.  Whenever
a type variable is encountered, its replacement type is pulled from the
context.

\section{Shifting}
Given the above pieces of the language, shifting functions are defined in
order to assist in evaluation.  Since both types and terms have variable
entities, both receive their own shifting functions.

For terms, the shifting function is \texttt{termShiftAbove}, which takes as
arguments two natural numbers and a term to work upon.  The first argument the
the number by which each free variable in the term should be increased.  The
second argument is a ``lower bound '' of which free variables should be
increased.  For example, \texttt{termShiftAbove 12 1 (Lam Nat (App (Var 1)
(Var 0)))} returns \texttt{Lam Nat (App (Var 1) (Var 0))}.  Even though there
is a free variable in \texttt{(Var 1)}, the second argument indicates that
only free variables with index larger than 1 should have 12 added to them.  In
contrast, \texttt{termShiftAbove 12 1 (Lam Nat (App (Var 2) (Var 0)))} returns
\texttt{Lam Nat (App (Var 14) (Var 0))}, since all free variables with index
greater than 1 are incremented by 12.  Also note that part of
\texttt{termShiftAbove}'s functionality requires that its second argument be
incremented by one each time it passes under a $\lambda$-abstraction.  To see
why, consider the fact that in a series of highly nested
$\lambda$-abstractions, free variables get ``further away''.  Incrementing
this second argument can be thought of as maintaining the minimum index any
free in the subterm might have.  Shifting for types works in a similar manner.

In contrast to \texttt{termShiftAbove}, which increments free variables by
a given value, \texttt{negTermShift} decrements free variables by a given
amount.  In Pierce's ML implementation, \texttt{termShiftAbove} can subtract
from the indices of free variables by passing in negative integers.  Since
Agda's type system is much stricter, \texttt{negTermShift} was defined to
handle subtraction and the complications associated with creating integers out
of natural numbers.

\section{Substitution}
Substitution is built upon the shifting functions outlined above.  The
function \texttt{termSubst} takes a ``lower bound'' natural number (similar to
\texttt{termShiftAbove}), a term that will be substituted, and a term upon
which the substitution will take place.  Again, the natural number argument is
incremented when passing under a $\lambda$-abstraction.  This time, it is in
an attempt to maintain the distance of the free variable from the outermost
$\lambda$-abstraction.  For example, \texttt{termSubst 0 (Num 15) (Lam Nat
(App (Var 0) (Var 1)))} produces \texttt{Lam Nat (App (Var 0) (Num 15))}.  The
initial argument of 0 is incremented to 1 when the function passes under the
abstraction, and the substitution occurs on \texttt{(Var 1)}.

For constant terms with no free variables, blind substitution as outlined
above works without difficulty.  But in order to substitute arbitrary
functions for variables, there needs to be a way to maintain the free and
bound variables of the function.  This notion is captured by the following
Agda code:
\begin{verbatim}
termSubst j s (Var x) with (== x j)
... | true  = (termShift j s)
... | false = (Var x)
\end{verbatim}
When the appropriate variable to be replaced is encountered, the call to
\texttt{(termShift j s)} will ensure that all free variables within \texttt{s}
remain free.  Since \texttt{j} can be thought of as the number of binders that
have been encountered so far, all free variables within \texttt{s} need to be
incremented by that many to remain free.  As an example, consider
\texttt{termSubst 0 (Lam Nat (App (Var 1) (Var 2))) (Lam Nat (Var 1))}, which
returns \texttt{Lam Nat (Lam Nat (App (Var 2) (Var 3)))} and maintains the
free variables in the second argument to \texttt{termSubst}.

Substitution at the type level is analogous.

Given a substituting term (type) \texttt{s} and a term (type) to work upon
\texttt{t}, \texttt{termSubstTop} will replace the free variables within
\texttt{t} that have the smallest index by \texttt{s}.  This is given by the
code
\begin{verbatim}
termSubstTop : Term -> Term -> Term
termSubstTop s t = negTermShift 1 (termSubst 0 (termShift 1 s) t)
\end{verbatim}
In this situation, it is assumed that the first free variable of \texttt{t}
has index 1.  Since \texttt{s} will be inserted under at least
1 $\lambda$-abstraction, all of its free variables are incremented by 1 within
the call to \texttt{termShift}.  But within the call to \texttt{termSubst},
all free variables within \texttt{s} are incremented again by its own call to
\texttt{termShift}.  Finally, \texttt{negTermShift} decrements all variables
by 1 and reflects the fact that \texttt{t} has one fewer free variable.

Substituting a type into a term proceeds by way of a call to
\texttt{typeSubst} upon a $\lambda$-abstraction's type variable annotation.

\section{Evaluation}
Evaluation proceeds in a straightforward fashion.  Because of the nameless
representation of variables, getting a variable's value corresponds to
indexing into the environment.Furthermore, the interpreter operates in
a call-by-value manner by evaluating arguments to function applications as far
as possible.

\section{Type Checking}
Type checking is also fairly standard.  One requirement is that both branches of an \texttt{If} statement have the same type; this is to prevent evaluation of the test associated with the \texttt{If} statement.  Also, although we assume well-typed, perfect inputs, the type checker will ensure that functions have arguments of the correct type.  This is done by way of the \texttt{isTypeAligned} function, which ensure that functions of the type $\tau \Rightarrow \sigma$ are given arguments of type $\tau$.
\end{document}
